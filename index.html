<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèéÔ∏è KART CHAOS 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
        }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 160px;
            height: 160px;
            background: radial-gradient(circle, rgba(0,0,0,0.8) 0%, rgba(20,0,0,0.95) 100%);
            border-radius: 50%;
            border: 4px solid #ff3300;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255,50,0,0.5);
        }
        
        #speed-value {
            font-size: 32px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
            transition: color 0.2s;
        }
        
        #speed-value.fast { color: #ffff00; text-shadow: 0 0 20px #ffff00; }
        #speed-value.insane { color: #ff0000; text-shadow: 0 0 30px #ff0000; animation: pulse 0.2s infinite; }
        
        @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.1)} }
        
        #speed-unit { font-size: 14px; color: #aaa; }
        
        #lap-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff3300, #ff0066);
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            z-index: 100;
            box-shadow: 0 5px 20px rgba(255,0,100,0.4);
        }
        
        #minimap {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #444;
            border-radius: 10px;
            z-index: 100;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            color: #aaa;
            font-size: 14px;
            z-index: 100;
        }
        
        #start-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #2a0a1e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #start-screen h1 {
            font-size: 64px;
            color: #fff;
            text-shadow: 0 0 30px #ff3300, 0 0 60px #ff0066, 0 0 90px #ff00ff;
            margin-bottom: 10px;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 30px #ff3300, 0 0 60px #ff0066; }
            to { text-shadow: 0 0 50px #00ffff, 0 0 80px #00ff88; }
        }
        
        #start-screen h2 {
            font-size: 28px;
            color: #ff6600;
            margin-bottom: 30px;
        }
        
        #start-screen p { font-size: 20px; color: #888; margin-bottom: 30px; }
        
        #start-btn {
            padding: 25px 70px;
            font-size: 32px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #ff3300, #ff0066);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 40px rgba(255,50,0,0.5);
            text-transform: uppercase;
        }
        
        #start-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 20px 60px rgba(255,50,0,0.7);
        }
        
        .boost-indicator {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
            opacity: 0;
            z-index: 150;
            pointer-events: none;
        }
        
        #nitro-bar {
            position: absolute;
            bottom: 210px;
            right: 65px;
            width: 40px;
            height: 180px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #00ffff;
            border-radius: 20px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        
        #nitro-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, #00ffff, #ff00ff, #ffff00);
            transition: height 0.1s;
        }
        
        #nitro-label {
            position: absolute;
            bottom: 395px;
            right: 60px;
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }
        
        #position-display {
            position: absolute;
            top: 80px;
            left: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px #ffd700;
            z-index: 100;
        }
        
        #powerup-display {
            position: absolute;
            top: 150px;
            left: 20px;
            font-size: 48px;
            z-index: 100;
            transition: transform 0.2s;
        }
        
        #combo-display {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 36px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #damage-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.3) 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 90;
            transition: opacity 0.2s;
        }
        
        #speed-lines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 80;
            opacity: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 48%,
                rgba(255,255,255,0.03) 50%,
                transparent 52%
            );
        }
        
        .screen-shake {
            animation: shake 0.1s infinite;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }
        
        #message-popup {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px currentColor;
            z-index: 160;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1>üèéÔ∏è KART CHAOS</h1>
            <h2>‚ö° EDI√á√ÉO TURBO INSANA ‚ö°</h2>
            <p>Rampas ‚Ä¢ Power-ups ‚Ä¢ Colis√µes ‚Ä¢ Caos Total!</p>
            <button id="start-btn">üî• COME√áAR üî•</button>
            <p style="margin-top: 40px; font-size: 16px; color: #555;">
                ‚Üë‚Üì Acelerar/Frear | ‚Üê‚Üí Virar | SPACE Nitro | E Usar Power-up | R Reiniciar
            </p>
        </div>
        
        <div id="damage-overlay"></div>
        <div id="speed-lines"></div>
        
        <div id="hud">
            <div>‚è±Ô∏è <span id="time">0:00.00</span></div>
            <div>üèÜ Melhor: <span id="best-time">--:--</span></div>
            <div>üí• Hits: <span id="hits">0</span></div>
        </div>
        
        <div id="lap-display">üèÅ Volta <span id="lap">1</span>/3</div>
        
        <div id="position-display">1¬∫</div>
        
        <div id="powerup-display"></div>
        
        <div id="combo-display">COMBO x1</div>
        
        <div id="speedometer">
            <span id="speed-value">0</span>
            <span id="speed-unit">km/h</span>
        </div>
        
        <div id="nitro-label">NITRO</div>
        <div id="nitro-bar">
            <div id="nitro-fill"></div>
        </div>
        
        <canvas id="minimap"></canvas>
        
        <div id="controls-hint">‚Üë‚Üì Acelerar | ‚Üê‚Üí Virar | SPACE Nitro | E Power-up</div>
        
        <div class="boost-indicator" id="boost-text">GO!</div>
        <div id="message-popup"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // KART CHAOS 3D - TURBO INSANO EDITION
        // ============================================
        
        let scene, camera, renderer;
        let kart, wheels = [];
        let opponents = [];
        let track, trackPath;
        let gameStarted = false;
        let raceTime = 0;
        let bestTime = null;
        let currentLap = 1;
        let lastCheckpoint = 0;
        let nitro = 100;
        let isUsingNitro = false;
        let currentPowerup = null;
        let hitCount = 0;
        let combo = 0;
        let lastHitTime = 0;
        let particles = [];
        let ramps = [];
        let powerupBoxes = [];
        let trails = [];
        
        // Physics
        const physics = {
            position: new THREE.Vector3(0, 0.3, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: 0,
            angularVelocity: 0,
            speed: 0,
            verticalVelocity: 0,
            airborne: false,
            spinAngle: 0,
            isSpinning: false
        };
        
        // TURBO PHYSICS!
        const PHYSICS = {
            MAX_SPEED: 5000,
            ACCELERATION: 1200,
            BRAKE_FORCE: 800,
            DRAG: 0.997,
            ROLLING_RESISTANCE: 0.9995,
            TURN_SPEED: 3.5,
            TURN_SPEED_FACTOR: 0.2,
            DRIFT_FACTOR: 0.7,
            GRAVITY: 60,
            NITRO_BOOST: 2.5,
            NITRO_CONSUMPTION: 12,
            NITRO_RECHARGE: 35,
            JUMP_FORCE: 35,
            BOUNCE: 0.3
        };
        
        const checkpoints = [];
        
        const keys = { up: false, down: false, left: false, right: false, space: false, e: false };
        
        const POWERUPS = {
            ROCKET: { emoji: 'üöÄ', name: 'FOGUETE', duration: 3000 },
            SHIELD: { emoji: 'üõ°Ô∏è', name: 'ESCUDO', duration: 5000 },
            LIGHTNING: { emoji: '‚ö°', name: 'RAIO', duration: 0 },
            BOMB: { emoji: 'üí£', name: 'BOMBA', duration: 0 },
            STAR: { emoji: '‚≠ê', name: 'ESTRELA', duration: 4000 },
            MAGNET: { emoji: 'üß≤', name: '√çM√ÉN', duration: 3000 }
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000022, 0.003);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('start-screen'));
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffcc, 1.2);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);
            
            // Colored point lights for atmosphere
            const colors = [0xff0066, 0x00ffff, 0xffff00, 0x00ff00];
            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 2, 100);
                light.position.set(
                    Math.cos(i * Math.PI / 2) * 80,
                    20,
                    Math.sin(i * Math.PI / 2) * 80 - 50
                );
                scene.add(light);
            });
            
            createSky();
            createTrack();
            createKart();
            createOpponents();
            createEnvironment();
            createRamps();
            createPowerupBoxes();
            setupEvents();
            
            animate();
        }
        
        function createSky() {
            // Starfield
            const starsGeo = new THREE.BufferGeometry();
            const starPositions = [];
            for (let i = 0; i < 2000; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 1000,
                    Math.random() * 300 + 50,
                    (Math.random() - 0.5) * 1000
                );
            }
            starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);
            
            // Gradient sky dome
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x000033) },
                    bottomColor: { value: new THREE.Color(0x220033) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(h, 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            scene.add(new THREE.Mesh(skyGeo, skyMat));
        }
        
        function createTrack() {
            // Bigger, crazier track!
            const trackPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(60, 0, 10),
                new THREE.Vector3(100, 0, -20),
                new THREE.Vector3(120, 0, -80),
                new THREE.Vector3(100, 0, -140),
                new THREE.Vector3(50, 0, -180),
                new THREE.Vector3(-20, 0, -190),
                new THREE.Vector3(-80, 0, -160),
                new THREE.Vector3(-120, 0, -100),
                new THREE.Vector3(-130, 0, -30),
                new THREE.Vector3(-100, 0, 30),
                new THREE.Vector3(-50, 0, 50),
                new THREE.Vector3(0, 0, 30),
            ];
            
            trackPath = new THREE.CatmullRomCurve3(trackPoints, true);
            
            const trackWidth = 22;
            const trackSegments = 300;
            
            // Glowing track
            const trackGeo = new THREE.TubeGeometry(trackPath, trackSegments, trackWidth/2, 8, true);
            const trackMat = new THREE.MeshStandardMaterial({ 
                color: 0x222233,
                roughness: 0.6,
                metalness: 0.3,
                emissive: 0x110022,
                emissiveIntensity: 0.2
            });
            track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.x = Math.PI / 2;
            track.position.y = -0.1;
            track.receiveShadow = true;
            scene.add(track);
            
            // Neon edge lines
            createNeonLines(trackPath, trackSegments, trackWidth);
            
            // Start line
            const startGeo = new THREE.PlaneGeometry(22, 4);
            const startCanvas = document.createElement('canvas');
            startCanvas.width = 256;
            startCanvas.height = 64;
            const ctx = startCanvas.getContext('2d');
            for (let i = 0; i < 16; i++) {
                for (let j = 0; j < 4; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#fff' : '#000';
                    ctx.fillRect(i * 16, j * 16, 16, 16);
                }
            }
            const startTex = new THREE.CanvasTexture(startCanvas);
            const startLine = new THREE.Mesh(startGeo, new THREE.MeshBasicMaterial({ map: startTex }));
            startLine.rotation.x = -Math.PI / 2;
            startLine.position.set(0, 0.05, 0);
            scene.add(startLine);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(600, 600);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x111122,
                roughness: 1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.3;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Checkpoints
            for (let i = 0; i < 12; i++) {
                const t = i / 12;
                checkpoints.push({ position: trackPath.getPointAt(t), t, passed: false });
            }
        }
        
        function createNeonLines(path, segments, width) {
            const points = path.getPoints(segments);
            
            [-1, 1].forEach((side, sideIndex) => {
                const linePoints = points.map((p, i) => {
                    const t = i / (points.length - 1);
                    const tangent = path.getTangentAt(t);
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    return new THREE.Vector3(
                        p.x + normal.x * (width/2 + 1) * side,
                        0.2,
                        p.z + normal.z * (width/2 + 1) * side
                    );
                });
                
                const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
                const colors = [0xff00ff, 0x00ffff];
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: colors[sideIndex],
                    linewidth: 3
                });
                const line = new THREE.Line(lineGeo, lineMat);
                scene.add(line);
                
                // Glow effect
                linePoints.forEach((p, i) => {
                    if (i % 10 === 0) {
                        const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
                        const glowMat = new THREE.MeshBasicMaterial({ 
                            color: colors[sideIndex],
                            transparent: true,
                            opacity: 0.6
                        });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        glow.position.copy(p);
                        scene.add(glow);
                    }
                });
            });
        }
        
        function createKart() {
            kart = new THREE.Group();
            
            // Futuristic body
            const bodyGeo = new THREE.BoxGeometry(1.8, 0.4, 2.8);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0033,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff0000,
                emissiveIntensity: 0.1
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.35;
            body.castShadow = true;
            kart.add(body);
            
            // Cockpit
            const cockpitGeo = new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpitMat = new THREE.MeshStandardMaterial({ 
                color: 0x000033,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.set(0, 0.55, -0.2);
            kart.add(cockpit);
            
            // Driver
            const headGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.set(0, 0.75, -0.2);
            kart.add(head);
            
            // Helmet
            const helmetGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const helmetMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0033,
                metalness: 0.7,
                roughness: 0.3
            });
            const helmet = new THREE.Mesh(helmetGeo, helmetMat);
            helmet.position.set(0, 0.8, -0.2);
            helmet.scale.y = 0.8;
            kart.add(helmet);
            
            // Wheels with glow
            const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                emissive: 0x00ffff,
                emissiveIntensity: 0.3
            });
            
            const wheelPositions = [
                { x: -0.9, y: 0.35, z: 1 },
                { x: 0.9, y: 0.35, z: 1 },
                { x: -0.9, y: 0.35, z: -0.9 },
                { x: 0.9, y: 0.35, z: -0.9 }
            ];
            
            wheelPositions.forEach((pos) => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                wheels.push(wheel);
                kart.add(wheel);
            });
            
            // Engine glow
            const engineGeo = new THREE.BoxGeometry(1.2, 0.3, 0.8);
            const engineMat = new THREE.MeshStandardMaterial({
                color: 0xff6600,
                emissive: 0xff3300,
                emissiveIntensity: 0.5
            });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.set(0, 0.3, -1.3);
            kart.add(engine);
            
            // Exhaust flames (will animate)
            [-0.4, 0.4].forEach(x => {
                const flameGeo = new THREE.ConeGeometry(0.15, 0.6, 8);
                const flameMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeo, flameMat);
                flame.rotation.x = Math.PI / 2;
                flame.position.set(x, 0.3, -1.7);
                flame.name = 'flame';
                kart.add(flame);
            });
            
            // Spoiler
            const spoilerGeo = new THREE.BoxGeometry(2, 0.1, 0.4);
            const spoiler = new THREE.Mesh(spoilerGeo, bodyMat);
            spoiler.position.set(0, 0.8, -1.3);
            kart.add(spoiler);
            
            kart.position.copy(physics.position);
            scene.add(kart);
        }
        
        function createOpponents() {
            const colors = [
                { body: 0x0066ff, name: 'AZUL' },
                { body: 0x00ff00, name: 'VERDE' },
                { body: 0xffff00, name: 'AMARELO' },
                { body: 0xff00ff, name: 'ROXO' },
                { body: 0xff8800, name: 'LARANJA' }
            ];
            
            colors.forEach((config, i) => {
                const opp = new THREE.Group();
                
                const bodyGeo = new THREE.BoxGeometry(1.8, 0.4, 2.8);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: config.body,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: config.body,
                    emissiveIntensity: 0.1
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.35;
                body.castShadow = true;
                opp.add(body);
                
                // Cockpit
                const cockpitGeo = new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const cockpitMat = new THREE.MeshStandardMaterial({ 
                    color: 0x000033,
                    transparent: true,
                    opacity: 0.7
                });
                const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
                cockpit.position.set(0, 0.55, -0.2);
                opp.add(cockpit);
                
                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                
                [[-0.9, 1], [0.9, 1], [-0.9, -0.9], [0.9, -0.9]].forEach(([x, z]) => {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(x, 0.35, z);
                    opp.add(wheel);
                });
                
                const startT = 0.08 + i * 0.12;
                const startPoint = trackPath.getPointAt(startT);
                opp.position.set(startPoint.x, 0.3, startPoint.z);
                
                opp.userData = {
                    t: startT,
                    speed: 1500 + Math.random() * 1000,
                    targetSpeed: 2500 + Math.random() * 1500,
                    lap: 1,
                    name: config.name,
                    stunned: false,
                    stunnedUntil: 0
                };
                
                scene.add(opp);
                opponents.push(opp);
            });
        }
        
        function createRamps() {
            const rampPositions = [0.15, 0.35, 0.55, 0.75, 0.92];
            
            rampPositions.forEach(t => {
                const point = trackPath.getPointAt(t);
                const tangent = trackPath.getTangentAt(t);
                
                const rampGeo = new THREE.BoxGeometry(8, 1.5, 4);
                const rampMat = new THREE.MeshStandardMaterial({
                    color: 0xffaa00,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.3
                });
                const ramp = new THREE.Mesh(rampGeo, rampMat);
                ramp.position.set(point.x, 0.5, point.z);
                ramp.rotation.y = Math.atan2(tangent.x, tangent.z);
                ramp.rotation.x = -0.3;
                ramp.castShadow = true;
                scene.add(ramp);
                
                // Arrow on ramp
                const arrowGeo = new THREE.ConeGeometry(1, 2, 3);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.rotation.x = -Math.PI / 2;
                arrow.position.set(point.x, 1.5, point.z);
                arrow.rotation.y = Math.atan2(tangent.x, tangent.z);
                scene.add(arrow);
                
                ramps.push({
                    position: point,
                    radius: 6
                });
            });
        }
        
        function createPowerupBoxes() {
            const boxPositions = [0.05, 0.2, 0.3, 0.45, 0.6, 0.7, 0.85, 0.95];
            
            boxPositions.forEach((t, i) => {
                const point = trackPath.getPointAt(t);
                
                const box = new THREE.Group();
                
                // Glowing cube
                const cubeGeo = new THREE.BoxGeometry(2, 2, 2);
                const cubeMat = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const cube = new THREE.Mesh(cubeGeo, cubeMat);
                box.add(cube);
                
                // Question mark
                const sprite = createTextSprite('?', '#ff0000', 80);
                sprite.scale.set(2, 2, 1);
                box.add(sprite);
                
                box.position.set(point.x, 2.5, point.z);
                box.userData = { 
                    t, 
                    collected: false, 
                    respawnTime: 0,
                    originalY: 2.5
                };
                
                scene.add(box);
                powerupBoxes.push(box);
            });
        }
        
        function createTextSprite(text, color, size) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = `bold ${size}px Arial`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            return new THREE.Sprite(material);
        }
        
        function createEnvironment() {
            // Neon buildings
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 100 + Math.random() * 150;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist - 70;
                
                createNeonBuilding(x, z);
            }
            
            // Floating rings (boost gates)
            for (let i = 0; i < 6; i++) {
                const t = (i + 0.5) / 6;
                const point = trackPath.getPointAt(t);
                createBoostRing(point.x, point.z, t);
            }
        }
        
        function createNeonBuilding(x, z) {
            const height = 20 + Math.random() * 60;
            const width = 5 + Math.random() * 15;
            
            const geo = new THREE.BoxGeometry(width, height, width);
            const colors = [0xff0066, 0x00ffff, 0xffff00, 0x00ff00, 0xff00ff];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const mat = new THREE.MeshStandardMaterial({
                color: 0x111122,
                emissive: color,
                emissiveIntensity: 0.1
            });
            
            const building = new THREE.Mesh(geo, mat);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            scene.add(building);
            
            // Neon strips
            const stripGeo = new THREE.BoxGeometry(width + 0.5, 1, width + 0.5);
            const stripMat = new THREE.MeshBasicMaterial({ color });
            
            for (let y = 5; y < height; y += 10) {
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set(x, y, z);
                scene.add(strip);
            }
        }
        
        function createBoostRing(x, z, t) {
            const ringGeo = new THREE.TorusGeometry(8, 0.5, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            
            const tangent = trackPath.getTangentAt(t);
            ring.position.set(x, 5, z);
            ring.rotation.y = Math.atan2(tangent.x, tangent.z);
            ring.rotation.x = Math.PI / 2;
            
            ring.userData = { isBoostRing: true, lastTriggered: 0 };
            scene.add(ring);
        }
        
        function setupEvents() {
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'ArrowUp': case 'KeyW': keys.up = true; break;
                    case 'ArrowDown': case 'KeyS': keys.down = true; break;
                    case 'ArrowLeft': case 'KeyA': keys.left = true; break;
                    case 'ArrowRight': case 'KeyD': keys.right = true; break;
                    case 'Space': keys.space = true; e.preventDefault(); break;
                    case 'KeyE': usePowerup(); break;
                    case 'KeyR': resetKart(); break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'ArrowUp': case 'KeyW': keys.up = false; break;
                    case 'ArrowDown': case 'KeyS': keys.down = false; break;
                    case 'ArrowLeft': case 'KeyA': keys.left = false; break;
                    case 'ArrowRight': case 'KeyD': keys.right = false; break;
                    case 'Space': keys.space = false; break;
                }
            });
            
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameStarted = true;
            raceTime = 0;
            currentLap = 1;
            hitCount = 0;
            resetKart();
            
            let countdown = 3;
            const interval = setInterval(() => {
                if (countdown > 0) {
                    showMessage(countdown.toString(), '#ffff00');
                    countdown--;
                } else {
                    showMessage('GO!', '#00ff00');
                    clearInterval(interval);
                }
            }, 1000);
        }
        
        function resetKart() {
            physics.position.set(0, 0.3, 5);
            physics.velocity.set(0, 0, 0);
            physics.rotation = 0;
            physics.angularVelocity = 0;
            physics.speed = 0;
            physics.verticalVelocity = 0;
            physics.airborne = false;
            physics.isSpinning = false;
            nitro = 100;
            currentPowerup = null;
            document.getElementById('powerup-display').textContent = '';
            checkpoints.forEach(cp => cp.passed = false);
        }
        
        function showMessage(text, color = '#ffffff') {
            const popup = document.getElementById('message-popup');
            popup.textContent = text;
            popup.style.color = color;
            popup.style.textShadow = `0 0 20px ${color}`;
            popup.style.opacity = 1;
            popup.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            setTimeout(() => {
                popup.style.opacity = 0;
                popup.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 800);
        }
        
        function showBoostText(text) {
            const el = document.getElementById('boost-text');
            el.textContent = text;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 600);
        }
        
        function collectPowerup() {
            const powerupTypes = Object.keys(POWERUPS);
            const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
            currentPowerup = { type, ...POWERUPS[type] };
            document.getElementById('powerup-display').textContent = currentPowerup.emoji;
            document.getElementById('powerup-display').style.transform = 'scale(1.5)';
            setTimeout(() => {
                document.getElementById('powerup-display').style.transform = 'scale(1)';
            }, 200);
            showMessage(currentPowerup.emoji + ' ' + currentPowerup.name, '#ffff00');
        }
        
        function usePowerup() {
            if (!currentPowerup || !gameStarted) return;
            
            const type = currentPowerup.type;
            
            switch(type) {
                case 'ROCKET':
                    physics.speed = Math.max(physics.speed, PHYSICS.MAX_SPEED * 0.9);
                    showMessage('üöÄ BOOST!', '#ff6600');
                    createExplosion(physics.position, 0xff6600);
                    break;
                    
                case 'SHIELD':
                    kart.userData.shielded = true;
                    kart.userData.shieldUntil = Date.now() + 5000;
                    showMessage('üõ°Ô∏è ESCUDO!', '#00ffff');
                    break;
                    
                case 'LIGHTNING':
                    opponents.forEach(opp => {
                        opp.userData.stunned = true;
                        opp.userData.stunnedUntil = Date.now() + 2000;
                        opp.userData.speed *= 0.3;
                        createExplosion(opp.position, 0xffff00);
                    });
                    showMessage('‚ö° RAIO!', '#ffff00');
                    break;
                    
                case 'BOMB':
                    opponents.forEach(opp => {
                        const dist = physics.position.distanceTo(opp.position);
                        if (dist < 30) {
                            opp.userData.speed *= 0.2;
                            opp.userData.stunned = true;
                            opp.userData.stunnedUntil = Date.now() + 3000;
                            createExplosion(opp.position, 0xff0000);
                        }
                    });
                    createExplosion(physics.position, 0xff0000);
                    showMessage('üí£ BOOM!', '#ff0000');
                    break;
                    
                case 'STAR':
                    kart.userData.invincible = true;
                    kart.userData.invincibleUntil = Date.now() + 4000;
                    physics.speed = PHYSICS.MAX_SPEED;
                    showMessage('‚≠ê INVENC√çVEL!', '#ffd700');
                    break;
                    
                case 'MAGNET':
                    // Pull towards first place
                    const leader = getLeader();
                    if (leader && leader !== 'player') {
                        const opp = opponents.find(o => o.userData.name === leader);
                        if (opp) {
                            const dir = new THREE.Vector3().subVectors(opp.position, physics.position).normalize();
                            physics.velocity.add(dir.multiplyScalar(50));
                        }
                    }
                    physics.speed += 1000;
                    showMessage('üß≤ MAGNETIZADO!', '#ff00ff');
                    break;
            }
            
            currentPowerup = null;
            document.getElementById('powerup-display').textContent = '';
        }
        
        function getLeader() {
            const positions = calculatePositions();
            return positions[0];
        }
        
        function createExplosion(position, color) {
            for (let i = 0; i < 30; i++) {
                const geo = new THREE.SphereGeometry(0.3, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 30,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 30
                );
                particle.life = 1;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity.clone().multiplyScalar(delta));
                p.velocity.y -= 40 * delta;
                p.life -= delta * 2;
                p.material.opacity = p.life;
                p.scale.setScalar(p.life);
                
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }
        
        function updatePhysics(delta) {
            if (!gameStarted) return;
            
            const dt = Math.min(delta, 0.05);
            
            // Input
            let throttle = keys.up ? 1 : 0;
            let brake = keys.down ? 1 : 0;
            let steerInput = (keys.left ? 1 : 0) - (keys.right ? 1 : 0);
            
            // Spinning recovery
            if (physics.isSpinning) {
                physics.spinAngle += 15 * dt;
                if (physics.spinAngle > Math.PI * 4) {
                    physics.isSpinning = false;
                    physics.spinAngle = 0;
                }
                steerInput = 0;
            }
            
            // Nitro
            isUsingNitro = keys.space && nitro > 0 && throttle > 0;
            if (isUsingNitro) {
                nitro = Math.max(0, nitro - PHYSICS.NITRO_CONSUMPTION * dt);
            } else {
                nitro = Math.min(100, nitro + PHYSICS.NITRO_RECHARGE * dt);
            }
            
            const maxSpeed = isUsingNitro ? PHYSICS.MAX_SPEED * PHYSICS.NITRO_BOOST : PHYSICS.MAX_SPEED;
            const accel = isUsingNitro ? PHYSICS.ACCELERATION * PHYSICS.NITRO_BOOST : PHYSICS.ACCELERATION;
            
            // Acceleration
            if (throttle > 0) physics.speed += accel * dt;
            if (brake > 0) physics.speed -= (physics.speed > 0 ? PHYSICS.BRAKE_FORCE : PHYSICS.ACCELERATION * 0.5) * dt;
            
            // Drag
            physics.speed *= PHYSICS.DRAG * PHYSICS.ROLLING_RESISTANCE;
            physics.speed = Math.max(-maxSpeed * 0.3, Math.min(maxSpeed, physics.speed));
            
            // Steering
            if (!physics.airborne && Math.abs(physics.speed) > 1) {
                const speedRatio = Math.abs(physics.speed) / PHYSICS.MAX_SPEED;
                const turnSpeed = PHYSICS.TURN_SPEED * (1 - speedRatio * PHYSICS.TURN_SPEED_FACTOR);
                physics.angularVelocity = steerInput * turnSpeed * Math.sign(physics.speed);
            }
            
            physics.rotation += physics.angularVelocity * dt;
            
            // Velocity
            const dir = new THREE.Vector3(Math.sin(physics.rotation), 0, Math.cos(physics.rotation));
            const speedMs = physics.speed / 3.6;
            
            physics.position.x += dir.x * speedMs * dt;
            physics.position.z += dir.z * speedMs * dt;
            
            // Gravity & jumping
            if (physics.airborne) {
                physics.verticalVelocity -= PHYSICS.GRAVITY * dt;
                physics.position.y += physics.verticalVelocity * dt;
                
                if (physics.position.y <= 0.3) {
                    physics.position.y = 0.3;
                    physics.airborne = false;
                    physics.verticalVelocity = 0;
                    
                    // Landing boost
                    if (physics.speed > 1000) {
                        physics.speed += 500;
                        showMessage('LANDING BOOST!', '#00ffff');
                    }
                }
            }
            
            // Ramp check
            ramps.forEach(ramp => {
                const dist = new THREE.Vector2(physics.position.x - ramp.position.x, physics.position.z - ramp.position.z).length();
                if (dist < ramp.radius && !physics.airborne && physics.speed > 500) {
                    physics.airborne = true;
                    physics.verticalVelocity = PHYSICS.JUMP_FORCE * (physics.speed / 2000);
                    showMessage('üöÄ AIRBORNE!', '#ffff00');
                }
            });
            
            // Powerup box collection
            powerupBoxes.forEach(box => {
                if (!box.userData.collected) {
                    const dist = physics.position.distanceTo(box.position);
                    if (dist < 4) {
                        box.userData.collected = true;
                        box.userData.respawnTime = Date.now() + 5000;
                        box.visible = false;
                        collectPowerup();
                    }
                } else if (Date.now() > box.userData.respawnTime) {
                    box.userData.collected = false;
                    box.visible = true;
                }
            });
            
            // Opponent collision
            opponents.forEach(opp => {
                const dist = physics.position.distanceTo(opp.position);
                if (dist < 3) {
                    const now = Date.now();
                    
                    if (kart.userData.invincible && now < kart.userData.invincibleUntil) {
                        // We're invincible - knock them away!
                        opp.userData.speed *= 0.3;
                        opp.userData.stunned = true;
                        opp.userData.stunnedUntil = now + 2000;
                        createExplosion(opp.position, 0xffd700);
                        
                        hitCount++;
                        combo++;
                        lastHitTime = now;
                        showMessage(`üí• HIT! x${combo}`, '#ff00ff');
                    } else if (!kart.userData.shielded || now > kart.userData.shieldUntil) {
                        // Collision!
                        const pushDir = new THREE.Vector3().subVectors(physics.position, opp.position).normalize();
                        physics.position.add(pushDir.multiplyScalar(2));
                        physics.speed *= 0.7;
                        
                        if (Math.random() > 0.7) {
                            physics.isSpinning = true;
                            physics.spinAngle = 0;
                        }
                        
                        // Screen shake
                        document.getElementById('game-container').classList.add('screen-shake');
                        setTimeout(() => document.getElementById('game-container').classList.remove('screen-shake'), 200);
                        
                        // Damage overlay
                        document.getElementById('damage-overlay').style.opacity = 0.5;
                        setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 200);
                    } else {
                        // Shield active
                        const pushDir = new THREE.Vector3().subVectors(opp.position, physics.position).normalize();
                        opp.position.add(pushDir.multiplyScalar(5));
                        opp.userData.speed *= 0.5;
                        createExplosion(opp.position, 0x00ffff);
                    }
                }
            });
            
            // Combo decay
            if (Date.now() - lastHitTime > 3000) combo = 0;
            
            // Update kart visual
            kart.position.copy(physics.position);
            kart.rotation.y = physics.rotation + physics.spinAngle;
            kart.rotation.z = -physics.angularVelocity * 0.15;
            
            // Tilt when airborne
            if (physics.airborne) {
                kart.rotation.x = physics.verticalVelocity * 0.01;
            } else {
                kart.rotation.x = 0;
            }
            
            // Wheel spin
            wheels.forEach((wheel, i) => {
                wheel.rotation.x += speedMs * 2 * dt;
                if (i < 2) wheel.rotation.y = steerInput * 0.4;
            });
            
            // Flame effects
            kart.children.filter(c => c.name === 'flame').forEach(flame => {
                const intensity = Math.abs(physics.speed) / PHYSICS.MAX_SPEED;
                flame.scale.z = 0.5 + intensity * 2 + (isUsingNitro ? 2 : 0);
                flame.material.color.setHex(isUsingNitro ? 0x00ffff : 0xff6600);
            });
            
            // Speed visual effects
            const speedRatio = Math.abs(physics.speed) / PHYSICS.MAX_SPEED;
            document.getElementById('speed-lines').style.opacity = speedRatio * 0.5;
            
            // Shield/invincibility glow
            if (kart.userData.invincible && Date.now() < kart.userData.invincibleUntil) {
                kart.children[0].material.emissive.setHex(0xffd700);
                kart.children[0].material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.02) * 0.3;
            } else if (kart.userData.shielded && Date.now() < kart.userData.shieldUntil) {
                kart.children[0].material.emissive.setHex(0x00ffff);
                kart.children[0].material.emissiveIntensity = 0.3;
            } else {
                kart.children[0].material.emissive.setHex(0xff0000);
                kart.children[0].material.emissiveIntensity = 0.1;
            }
            
            checkCheckpoints();
            raceTime += dt;
        }
        
        function checkCheckpoints() {
            checkpoints.forEach((cp, i) => {
                if (!cp.passed) {
                    const dist = physics.position.distanceTo(cp.position);
                    if (dist < 18) {
                        if (i === 0 && lastCheckpoint >= checkpoints.length - 2) {
                            cp.passed = true;
                            lastCheckpoint = 0;
                            
                            if (currentLap < 3) {
                                currentLap++;
                                showMessage(`üèÅ VOLTA ${currentLap}!`, '#00ff00');
                                checkpoints.forEach(c => c.passed = false);
                            } else {
                                finishRace();
                            }
                        } else if (i === lastCheckpoint + 1 || (lastCheckpoint === 0 && i === 1)) {
                            cp.passed = true;
                            lastCheckpoint = i;
                        }
                    }
                }
            });
        }
        
        function finishRace() {
            showMessage('üèÜ CHEGOU!', '#ffd700');
            
            if (!bestTime || raceTime < bestTime) {
                bestTime = raceTime;
                document.getElementById('best-time').textContent = formatTime(bestTime);
                showMessage('üéâ NOVO RECORDE!', '#ff00ff');
            }
            
            setTimeout(() => {
                if (confirm(`üèÅ TEMPO: ${formatTime(raceTime)}\nüí• HITS: ${hitCount}\n\nüîÑ Jogar novamente?`)) {
                    currentLap = 1;
                    raceTime = 0;
                    hitCount = 0;
                    resetKart();
                    lastCheckpoint = 0;
                    
                    opponents.forEach((opp, i) => {
                        opp.userData.t = 0.08 + i * 0.12;
                        opp.userData.lap = 1;
                        opp.userData.stunned = false;
                    });
                }
            }, 2000);
        }
        
        function updateOpponents(delta) {
            opponents.forEach((opp) => {
                const data = opp.userData;
                
                // Stun recovery
                if (data.stunned && Date.now() > data.stunnedUntil) {
                    data.stunned = false;
                    data.speed = data.targetSpeed;
                }
                
                // Move along track
                if (!data.stunned) {
                    data.speed += (data.targetSpeed - data.speed) * delta;
                    data.t += (data.speed / 3.6) * delta * 0.002;
                    
                    if (data.t >= 1) {
                        data.t -= 1;
                        data.lap++;
                    }
                }
                
                // Position
                const point = trackPath.getPointAt(data.t);
                const nextPoint = trackPath.getPointAt((data.t + 0.01) % 1);
                
                const offset = Math.sin(data.t * 8 + opponents.indexOf(opp) * 2) * 4;
                const tangent = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);
                
                opp.position.x = point.x + normal.x * offset;
                opp.position.z = point.z + normal.z * offset;
                opp.position.y = 0.3;
                
                opp.lookAt(nextPoint.x + normal.x * offset, 0.3, nextPoint.z + normal.z * offset);
                
                // Stunned visual
                if (data.stunned) {
                    opp.rotation.y += delta * 10;
                }
            });
        }
        
        function updateCamera() {
            // Dynamic FOV based on speed
            const speedRatio = Math.abs(physics.speed) / PHYSICS.MAX_SPEED;
            camera.fov = 75 + speedRatio * 30;
            camera.updateProjectionMatrix();
            
            // Chase camera
            const cameraHeight = physics.airborne ? 6 : 4;
            const cameraDistance = 10 + speedRatio * 3;
            
            const offset = new THREE.Vector3(0, cameraHeight, -cameraDistance);
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), physics.rotation);
            
            const targetPos = physics.position.clone().add(offset);
            camera.position.lerp(targetPos, 0.15);
            
            const lookOffset = new THREE.Vector3(0, 1, 8).applyAxisAngle(new THREE.Vector3(0, 1, 0), physics.rotation);
            camera.lookAt(physics.position.clone().add(lookOffset));
        }
        
        function updateHUD() {
            const speed = Math.abs(Math.round(physics.speed));
            const speedEl = document.getElementById('speed-value');
            speedEl.textContent = speed;
            
            speedEl.className = '';
            if (speed > 3000) speedEl.classList.add('insane');
            else if (speed > 1500) speedEl.classList.add('fast');
            
            document.getElementById('time').textContent = formatTime(raceTime);
            document.getElementById('lap').textContent = currentLap;
            document.getElementById('nitro-fill').style.height = nitro + '%';
            document.getElementById('hits').textContent = hitCount;
            
            // Position
            const positions = calculatePositions();
            const playerPos = positions.indexOf('player') + 1;
            document.getElementById('position-display').textContent = playerPos + '¬∫';
            
            // Combo
            const comboEl = document.getElementById('combo-display');
            if (combo > 0) {
                comboEl.textContent = `COMBO x${combo}`;
                comboEl.style.opacity = 1;
            } else {
                comboEl.style.opacity = 0;
            }
            
            updateMinimap();
        }
        
        function calculatePositions() {
            const racers = [{ id: 'player', progress: lastCheckpoint / checkpoints.length + (currentLap - 1) }];
            opponents.forEach(opp => {
                racers.push({ id: opp.userData.name, progress: opp.userData.t + (opp.userData.lap - 1) });
            });
            racers.sort((a, b) => b.progress - a.progress);
            return racers.map(r => r.id);
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            canvas.width = 180;
            canvas.height = 180;
            
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 180, 180);
            
            // Track
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 10;
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const point = trackPath.getPointAt(t);
                const x = 90 + point.x * 0.6;
                const y = 100 - point.z * 0.5;
                t === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Player
            ctx.fillStyle = '#ff0033';
            ctx.shadowColor = '#ff0033';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(90 + physics.position.x * 0.6, 100 - physics.position.z * 0.5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Opponents
            ctx.shadowBlur = 5;
            const oppColors = ['#0066ff', '#00ff00', '#ffff00', '#ff00ff', '#ff8800'];
            opponents.forEach((opp, i) => {
                ctx.fillStyle = oppColors[i];
                ctx.shadowColor = oppColors[i];
                ctx.beginPath();
                ctx.arc(90 + opp.position.x * 0.6, 100 - opp.position.z * 0.5, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function formatTime(s) {
            const mins = Math.floor(s / 60);
            const secs = Math.floor(s % 60);
            const ms = Math.floor((s % 1) * 100);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }
        
        // Animate powerup boxes
        function animateBoxes() {
            powerupBoxes.forEach(box => {
                if (!box.userData.collected) {
                    box.rotation.y += 0.03;
                    box.position.y = box.userData.originalY + Math.sin(Date.now() * 0.004) * 0.5;
                }
            });
        }
        
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (gameStarted) {
                updatePhysics(delta);
                updateOpponents(delta);
                updateCamera();
                updateHUD();
                updateParticles(delta);
            } else {
                camera.position.set(
                    Math.cos(currentTime * 0.0002) * 80,
                    40,
                    Math.sin(currentTime * 0.0002) * 80 - 70
                );
                camera.lookAt(0, 0, -70);
            }
            
            animateBoxes();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
